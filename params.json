{
  "name": "Libmsrp-for-windows",
  "tagline": "libMSRP (http://sourceforge.net/projects/libmsrp/) is an open source MSRP (Message Session Relay Protocol) library written in C. libMSRP for Windows is the windows version of libMSRP.",
  "body": "===================\r\nlibMSRP for Windows\r\n===================\r\n\r\nlibMSRP (http://sourceforge.net/projects/libmsrp/) is an open source MSRP (Message Session Relay Protocol) library written in C. libMSRP for Windows is the windows version of libMSRP.\r\n\r\n==========================\r\nCompile with Visual Studio\r\n==========================\r\n\r\nRequirements:\r\n\r\nWindows XP SP2\r\nVisual Studio 2005\r\nMicrosoft Platform SDK for Windows Server 2003 R2\r\n\r\nOpen msrp.sln and click \"Build->Build Solution\".\r\nCompiling the library in MinGW for Windows:\r\n\r\n==================\r\nCompile with MinGW\r\n==================\r\nCopy the Makefile_for_MinGW to Makefile\r\n\r\n$ make\r\n\r\n\r\n\r\n\r\n=================\r\nlibMSRP for Linux\r\n=================\r\n\r\nhttp://confiance.sourceforge.net/\r\n\r\n=====\r\nNOTES\r\n=====\r\n\r\nThis is a brief guide to the compilation of the MSRP (Message\r\nSession Relay Protocol) library, according to draft specifications\r\n(attached), and of the test programs that has been made available\r\nto show its use. This library is currently being used in the\r\nConfiance conferencing framework (http://confiance.sourceforge.net/)\r\nto provide MSRP support.\r\n\r\nThis guide has been conceived by installing the applications on\r\na Linux RedHat Fedora Core 6, but it should not give any problem\r\non different distributions.\r\n\r\nA Windows version of the library is still not available due\r\nto some non-portable methods being currently used (e.g. socketpair)\r\nbut it soon will. If you make a Win32 version of the library by\r\nfixing the current issues, please let me know at\r\n\r\n\tlorenzo.miniero@unina.it\r\n\r\n\r\n=====\r\nINDEX\r\n=====\r\n\r\n1. Compiling the library\r\n2. Testing the library as endpoint\r\n3. Testing the library as switch\r\n\r\n\r\n\r\n========================\r\n1. Compiling the library\r\n========================\r\n\r\nEdit the Makefile according to your settings and compiler.\r\nBy default gcc will be used, and the library installed\r\nto /usr as destination prefix (/usr/include, /usr/lib).\r\n\r\nTo compile the library, type:\r\n\r\n\tmake so\r\n\r\nThis will build the shared object for the library.\r\nTo install it, type, as root:\r\n\r\n\tmake install\r\n\r\nIf you want to compile the test executables for the library,\r\ntype:\r\n\r\n\tmake test\r\n\r\nThis will build two executables:\r\n\r\n\t- endpointmsrp, which will enable you to access the\r\n\t\t\tMSRP functionality as an endpoint\r\n\t\t\t(e.g. an IM client);\r\n\t- switchmsrp,\twhich will enable you to create an\r\n\t\t\tMSRP switch (i.e. a conference room).\r\n\r\n\r\n==================================\r\n2. Testing the library as endpoint\r\n==================================\r\n\r\nTo test the endpoint functionality, launch the endpointmsrp\r\nexecutable. This test application will need a text file\r\ncontaining some basic configuration settings. A sample\r\nis in the conf subdirectory (conf/endpoint.conf):\r\n\r\n\t- debug:\tif you set debug to 1, you'll get\r\n\t\t\tmany notifications printed on screen,\r\n\t\t\tboth for log messages and errors.\r\n\t\t\tBy default it is 0.\r\n\t- callid:\tthis is the Call-ID of the SIP session\r\n\t\t\tthe MSRP connection will be associated\r\n\t\t\twith. Since this is an example, no\r\n\t\t\tSIP/SDP negotiation happens, so we\r\n\t\t\tpass it here.\r\n\t- label:\tthis is the label associated with the\r\n\t\t\tMSRP media stream in SDP, if needed.\r\n\t\t\tAs before, this is a fake value.\r\n\t- active:\ta 0 value means a passive endpoint (act\r\n\t\t\tas MSRP server and wait for the connection\r\n\t\t\tfrom the negotiated MSRP peer), while\r\n\t\t\ta 1 value means an active endpoint (act\r\n\t\t\tas a clint, and connect to the negotiated\r\n\t\t\tpeer). For a correct behaviour of the library,\r\n\t\t\tthe server should know both the peers\r\n\t\t\t(i.e. itself, 'From', and the client, 'To')\r\n\t\t\tbefore the client does, since the client\r\n\t\t\twill connect as soon as msrp_endpoint_set_to\r\n\t\t\tis called.\r\n\t- address:\tthis is the address the MSRP library will\r\n\t\t\tuse to build the endpoint's MSRP path.\r\n\t- port:\t\tthis is the port number the endpoint will\r\n\t\t\tbind to. This is true for both servers and\r\n\t\t\tclients, since they get negotiated via SDP.\r\n\t\t\tif set to 0, a random port number will be\r\n\t\t\tchosen by the library. Once the endpoint\r\n\t\t\tbinds to the port, this port is used to\r\n\t\t\tbuild the endpoint's MSRP path.\r\n\t- display:\tthe nickname to be used. This is only for\r\n\t\t\tvisualization purposes (i.e. it is local\r\n\t\t\tto the application), since MSRP uses SIP\r\n\t\t\tdisplay identifiers as nicknames.\r\n\r\nA typical example to try the application is to have two endpoints\r\ntalking to each other. Setup two different configuration files,\r\none active and one passive, and then launch two instances of\r\nthe application, e.g.:\r\n\r\n\t./endpointmsrp alice.conf\r\n\r\nwith alice.conf (server endpoint, active is 0):\r\n\r\n\tdebug=0\r\n\tcall_id=3413an89KU\r\n\tlabel=11\r\n\tactive=0\r\n\taddress=127.0.0.1\r\n\tport=0\r\n\tdisplay=Alice\r\n\r\nand:\r\n\r\n\t./endpointmsrp bob.conf\r\n\r\nwith alice.conf (client endpoint, active is 1):\r\n\r\n\tdebug=0\r\n\tcall_id=3413an89KU\r\n\tlabel=22\r\n\tactive=1\r\n\taddress=127.0.0.1\r\n\tport=8888\r\n\tdisplay=Bob\r\n\r\nThe call-IDs in real world scenarios will typically be the same,\r\nsince they will identify a SIP session. Since no actual SDP\r\nnegotiation is involved, it will be simulated through console\r\ninteraction. \r\nOnce the server starts, you'll see something like this:\r\n\r\n\tConfiguration file: alice.conf\r\n\t\tDebug:          no\r\n\t\tCall-ID:        3413an89KU\r\n\t\tLabel:          11\r\n\t\tActive:         no\r\n\t\tAddress:        127.0.0.1\r\n\t\tPort:           0\r\n\t\tDisplay:        Alice\r\n\t\tNo 'port' in alice.conf, choosing random one\r\n\t\r\n\tMSRP library initialized.\r\n\tNew endpoint (ID 1) created:\r\n\t\tCall-ID:        3413an89KU\r\n\t\tLabel:          11\r\n\t\tFrom:           msrp://127.0.0.1:2832/1e4d2c216b02;tcp (passive)\r\n\r\nWe wanted a random port, and 2832 has been taken. Besides, a\r\nrandom session identifier has been picked up (1e4d2c216b02).\r\nAs a result, the 'From' string identifies Alice's MSRP path.\r\n\r\nOn the client side:\r\n\r\n\tConfiguration file: bob.conf\r\n\t\tDebug:          no\r\n\t\tCall-ID:        3413an89KU\r\n\t\tLabel:          22\r\n\t\tActive:         yes\r\n\t\tAddress:        127.0.0.1\r\n\t\tPort:           8888\r\n\t\tDisplay:        Bob\r\n\t\r\n\tMSRP library initialized.\r\n\tNew endpoint (ID 1) created:\r\n\t\tCall-ID:        n89KU3413a\r\n\t\tLabel:          22\r\n\t\tFrom:           msrp://127.0.0.1:8888/5ff8dd6225c1;tcp (active)\r\n\r\nWe wanted for Bob to explicitely bind to 8888, and it has\r\nbeen done. A random session identifier has been picked up\r\n(5ff8dd6225c1), and as before the 'From' string identifies\r\nBob's MSRP path.\r\n\r\nNow that both endpoints have a valid MSRP path, they'll need\r\nto exchange it with each other to start to communicate. This\r\nis typically done by means of a SIP/SDP offer/answer negotiation\r\nmechanism. Since it is only simulated here, take Bob's path\r\n(the client) and pass it to Alice:\r\n\r\n\tInsert your peer's nickname (for visualization only): Bob\r\n\tInsert the full 'To' path: msrp://127.0.0.1:8888/5ff8dd6225c1;tcp\r\n\t\tTo:             msrp://127.0.0.1:8888/5ff8dd6225c1;tcp (active)\r\n\r\nSetting the peer has made the server start listening on the port.\r\nNow take Alice's path (the server) and pass it to Bob:\r\n\r\n\tInsert your peer's nickname (for visualization only): Alice\r\n\tInsert the full 'To' path: msrp://127.0.0.1:2832/1e4d2c216b02;tcp\r\n\tEndpoint 1: we connected towards 'To' (msrp://127.0.0.1:2832/1e4d2c216b02;tcp)\r\n\t\tTo:             msrp://127.0.0.1:2832/1e4d2c216b02;tcp (passive)\r\n\r\nAs you can see, setting the peer made the client connect to it.\r\nIn fact, in Alice's application you can see:\r\n\r\n\tEndpoint 1: 'To' connected to us (msrp://127.0.0.1:8888/5ff8dd6225c1;tcp)\r\n\r\nAt this point, the two MSRP endpoints are connected, and can start\r\nchatting. A disconnection of one of the peers will be notified to\r\nthe other.\r\n\r\nHave a look at the code to see how all this can be accomplished\r\nusing the MSRP library.\r\n\r\n\r\n================================\r\n3. Testing the library as switch\r\n================================\r\n\r\nThe library can act as an MSRP switch as well. Switching means\r\nhaving a single listening MSRP path to which other active endpoints\r\nconnect to: each message an endpoint will send will then be\r\nforwarded to all the other attached endpoints. This switch\r\nfunctionality implements an MSRP conference chat room.\r\nAnnouncements (both to a single endpoint or to all endpoints)\r\ncan be made on a switch. Besides, moderation is envisaged: this is\r\naccomplished on the application side, to allow for example floor\r\ncontrol to decide who can talk and who can't.\r\n\r\nTo test the switching functionality, launch the switchmsrp\r\nexecutable. This test application will need a text file\r\ncontaining some basic configuration settings. A sample\r\nis in the conf subdirectory (conf/switch.conf):\r\n\r\n\t- debug:\tif you set debug to 1, you'll get\r\n\t\t\tmany notifications printed on screen,\r\n\t\t\tboth for log messages and errors.\r\n\t\t\tBy default it is 0.\r\n\t- welcome:\tthis is a welcome message that is\r\n\t\t\tsent as an announcement to a user\r\n\t\t\tas soon as she/he joins the conference\r\n\t\t\troom. This of course is not the default\r\n\t\t\tbehavior of the library, and is only\r\n\t\t\tthere to show the single announcement\r\n\t\t\tfeature.\r\n\t- address:\tthis is the address the MSRP library will\r\n\t\t\tuse to build the switch's MSRP path.\r\n\t- port:\t\tthis is the port number the switch will\r\n\t\t\tbind to and listen on as a server.\r\n\t\t\tIf set to 0, a random port number will be\r\n\t\t\tchosen by the library. Once the switch\r\n\t\t\tbinds to the port, this port is used to\r\n\t\t\tbuild the conference MSRP path.\r\n\r\nA typical example to try the application is to have two or more\r\nendpoints talking to each other on the same chat room. Setup \r\ndifferent configuration files for the endpoints as described\r\npreviously. They will need to be setup as active, of course,\r\nsince the switch will be the server. Then prepare a configuration\r\nfile for the switch and launch it:\r\n\r\n\t./switchmsrp switch.conf\r\n\r\nwith switch.conf:\r\n\r\n\tdebug=0\r\n\twelcome=Welcome to this sample MSRP conference\r\n\taddress=127.0.0.1\r\n\tport=0\r\n\r\nAfter launched, a menu with several options will appear.\r\nUse the \"Add User\" voice to add endpoints to the conference,\r\nby following the same guidelines of the previous section:\r\nin this scenario, all endpoints will have the same endpoint\r\n(the switch) as server peer (which before was Alice).\r\n\r\nHave a look at the code to see how an MSRP conference room\r\nservice can be accomplished using the library.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}